{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-03T00:31:03.856603+00:00",
  "repo": "peppelinux/draft-demarco-acme-openid-federation",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOJ6_NW859ms0D",
      "title": "specialized keys by scopes",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/issues/1",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "we need a way (optional) to define the scope of the key where the issued certificate is related to",
      "createdAt": "2024-01-30T09:07:23Z",
      "updatedAt": "2024-01-30T09:07:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOJ6_NW86UD4xZ",
      "title": "Questions regarding the specification",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/issues/2",
      "state": "OPEN",
      "author": "branlwyd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I gave the specification (as well as the ACME & OpenID Federation specs) a readthrough. I have a few initial questions:\r\n\r\n1) What kind of X.509 certificates are intended to be generated? For example, the original ACME specification generates domain-validated Web PKI certificates (RFC 8555). It has been extended to create S/MIME certificates (RFC 8823), VoIP certificates (RFC 9448), and probably others. The text in Section 6.8 suggests this may be a Web PKI certificate, but this is not totally clear.\r\n\r\n2) It looks like the ACME authorizations/challenges functionality is not used in this proposal (Section 6.7 says it `MUST` be omitted from the `newOrder` response). Instead, my understanding is that issuance is authorized by having the `newOrder` request signed by a private key controlled by the Requestor & published in its Entity Configuration (Section 5), which may be discovered by the Issuer or included in a new `trust_chain` request field. Is this accurate?\r\n\r\n[nit: Section 5 says the `newOrder` request is signed by the Requestor's private key, while Section 6.2 suggests that the `newNonce` request requires validation. Perhaps both should be?]\r\n\r\n3) Given that requests are expected to be signed with the Requestor's private key, how does this play with standard ACME account management? Standard ACME account management maintains that each client will maintain its own keypair, and each request is authorized by a signature over the request with the account's private key.\r\n\r\n\r\nAnd a final meta-question, wrapping up the previous three questions: why can't this method of authorizing issuance be phrased as a new challenge type, using ACME's existing authorization/challenge/response APIs? For example, the challenge would include a nonce, and the response would involve providing a signature over the nonce with the Entity Key. This would fit more closely to ACME as defined in RFC 8555 as well as existing extensions.",
      "createdAt": "2024-08-23T23:43:26Z",
      "updatedAt": "2024-08-30T23:36:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "peppelinux",
          "authorAssociation": "OWNER",
          "body": "Hi @branlwyd, thank you for your analysis and apologies for the late in reply\r\n\r\n1. in RFC7517, then in the JWK sets, we don't have any particular extension like the ones that might be possibile using X.509. OpenID Federation and its Entity Configurations carrying JWKs doesn't give this kind of detail. I assume for now that any X.509 extension would be exclusively in the scope of the ACME request therefore configured in the CSR. We can evaluate any further feature or requirement, therefore if of interest we can do any proposals for this point.\r\n\r\n2. yes it is accurate. Another issue is that in the current text we only mention/use Federation JWK and not metadata JWK. I believe that we need to include also metadata JWK, therefore the ACME request, including the jwk id (`kid`), must contain the pointer to the jwk inteded to be used for the evaluation. the trust chain is build, the federation jwks and any metadata specific jwks resolved, and then the public key material contained in the CSR must be matched with the specific jwk included in the acme request. If we need to clarify this point we can accurately define an issue with the instruction where and how to include this detail and therefore having another draft.\r\n\r\n2.1  good catch. I see that the check described in the following sentence cannot be evaluated by the issuer `The Requestor checks if its superior Federation Entity supports the ACME protocol for OpenID Connect Federation 1.0. If not, the Requestor starts the discovery process to find which are the Issuers within the federation.` . We can say that at that stage, i nthe nonce endpoint, the issuer doesn't have any way to know if the requestor is a federation participant, since from the http perspective the issuer has only the requestor's IP and not the requestor federation entity id. **This is an issue to be resolved in the current draft**.\r\n\r\n3. in multilateral federation the account is something that might be preestablished. an accout might rely on some bilateral contracts or relationship stipulated before the ACME request. It is in the scope of this draft enable the trust evaluation in the context of the multilateral federation allowing a more flexible x.509 certificate issuance according to the evidences evaluated though openid federation. In this draft the requestor's keys are not configured in a preconfigured account but in its trust chain dynamically evaluated during the ACME request. This must not alienate us, we might enable the account creation as well using openid federation; the current proposal aims to simplify by removing steps not necessarly of interest in the multilateral federations (or, at least for now, in my modest perception)\r\n\r\nfinal question/answer: the more we can reuse preexisting ACME approaches the more we can reduce implementation efforts. I support any change to the draft that aims to go in this direction of preserving legacy ACME implementation and using the less effort to include openid federation like a sort of wrapper, that might work around the ACME challenges and any other legacy artifact involved in the traditional flow.\r\n\r\ntherefore, if you want to propose a breaking change with your proposal please open a draft PR and consider all my support during the revision for releasing together the next draft\r\n\r\n\r\n ",
          "createdAt": "2024-08-27T21:40:54Z",
          "updatedAt": "2024-08-27T21:43:40Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "body": "1. Sounds good; I think we eventually need to think through what kind of CSRs are acceptable, but this doesn't need to be spelled out in the spec (RFC 8555 & RFC 8823 spell out CSR requirements in general terms; RFC 9448 provides more detail but still looks non-comprehensive).\r\n\r\nFinal: Sounds good, I will open a PR in the next few days -- it will likely phrase the authorization logic as a new challenge type.",
          "createdAt": "2024-08-28T20:44:34Z",
          "updatedAt": "2024-08-28T20:44:34Z"
        },
        {
          "author": "branlwyd",
          "authorAssociation": "NONE",
          "body": "I sent https://github.com/peppelinux/draft-demarco-acme-openid-federation/pull/3 as a WIP example of my suggestion to phrase the validation as a new ACME challenge type. Feedback very welcome; I will clean it up and turn it into a proper PR if the approach is acceptable.",
          "createdAt": "2024-08-30T23:36:15Z",
          "updatedAt": "2024-08-30T23:36:15Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOJ6_NW856CIbm",
      "title": "WIP: rephrase OpenID federation validation as a new challenge type.",
      "url": "https://github.com/peppelinux/draft-demarco-acme-openid-federation/pull/3",
      "state": "OPEN",
      "author": "branlwyd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-08-30T23:32:27Z",
      "updatedAt": "2024-08-30T23:32:27Z",
      "baseRepository": "peppelinux/draft-demarco-acme-openid-federation",
      "baseRefName": "main",
      "baseRefOid": "5f1e34bcb3bdd432f146773537c3cca10c9b6c8a",
      "headRepository": "branlwyd/draft-demarco-acme-openid-federation",
      "headRefName": "bran/challenge",
      "headRefOid": "6d6606f07542c0ff8db29e77a496d801403483c3",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}